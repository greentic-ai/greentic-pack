use crate::flows::FlowAsset;
use crate::templates::TemplateAsset;
use anyhow::{Context, Result};
use std::fmt::Write;
use std::fs;
use std::path::{Path, PathBuf};
use std::process::Command;
use tracing::info;

pub fn generate_component_data(
    manifest_bytes: &[u8],
    flows: &[FlowAsset],
    templates: &[TemplateAsset],
) -> Result<String> {
    let mut buffer = String::new();
    writeln!(
        &mut buffer,
        "// @generated by packc -- DO NOT EDIT BY HAND."
    )?;
    writeln!(&mut buffer, "#![allow(dead_code)]")?;
    writeln!(&mut buffer, "#![allow(clippy::all)]\n")?;

    writeln!(&mut buffer, "pub static MANIFEST_CBOR: &[u8] = &[")?;
    buffer.push_str(&indent_byte_literal(manifest_bytes, 4));
    writeln!(&mut buffer, "\n];\n")?;

    writeln!(
        &mut buffer,
        "pub static FLOWS: &[(&'static str, &'static str)] = &["
    )?;
    for flow in flows {
        let raw_literal = rust_string_literal(&flow.raw);
        writeln!(&mut buffer, "    (\"{}\", {}),", flow.id, raw_literal)?;
    }
    writeln!(&mut buffer, "];\n")?;

    writeln!(
        &mut buffer,
        "pub static TEMPLATES: &[(&'static str, &'static [u8])] = &["
    )?;
    for template in templates {
        writeln!(&mut buffer, "    (\"{}\", &[", template.logical_path)?;
        buffer.push_str(&indent_byte_literal(&template.bytes, 8));
        writeln!(&mut buffer, "\n    ]),")?;
    }
    writeln!(&mut buffer, "];\n")?;

    Ok(buffer)
}

pub fn compile_component(component_data: &Path, output_wasm: &Path) -> Result<()> {
    let workspace_root = workspace_root();

    info!(
        component_data = %component_data.display(),
        output = %output_wasm.display(),
        "compiling pack_component"
    );

    ensure_target_installed("wasm32-unknown-unknown")?;

    let status = Command::new("cargo")
        .args([
            "build",
            "--package",
            "pack_component",
            "--target",
            "wasm32-unknown-unknown",
            "--release",
        ])
        .current_dir(&workspace_root)
        .status()
        .with_context(|| "failed to invoke cargo build for pack_component")?;

    if !status.success() {
        anyhow::bail!("cargo build failed with status {}", status);
    }

    let artifact = workspace_root
        .join("target")
        .join("wasm32-unknown-unknown")
        .join("release")
        .join("pack_component.wasm");

    if !artifact.exists() {
        anyhow::bail!(
            "expected wasm artifact at {} but it was not produced",
            artifact.display()
        );
    }

    if let Some(parent) = output_wasm.parent() {
        fs::create_dir_all(parent)
            .with_context(|| format!("failed to create directory {}", parent.display()))?;
    }

    fs::copy(&artifact, output_wasm).with_context(|| {
        format!(
            "failed to copy wasm artifact from {} to {}",
            artifact.display(),
            output_wasm.display()
        )
    })?;

    info!(artifact = %artifact.display(), output = %output_wasm.display(), "component artifact ready");
    Ok(())
}

fn ensure_target_installed(target: &str) -> Result<()> {
    let output = Command::new("rustup")
        .args(["target", "list", "--installed"])
        .output();

    let Ok(output) = output else {
        // If rustup is unavailable we assume the caller will manage targets manually.
        info!("skipping rustup target check; rustup not available");
        return Ok(());
    };

    if !output.status.success() {
        info!("rustup target list --installed failed; assuming target is configured");
        return Ok(());
    }

    let stdout = String::from_utf8_lossy(&output.stdout);
    if stdout.lines().any(|line| line.trim() == target) {
        Ok(())
    } else {
        anyhow::bail!(
            "Rust target `{}` is not installed. Install it via `rustup target add {}` before running packc.",
            target,
            target
        );
    }
}

fn indent_byte_literal(bytes: &[u8], indent: usize) -> String {
    if bytes.is_empty() {
        return String::new();
    }

    let mut lines = Vec::new();
    for chunk in bytes.chunks(12) {
        let mut line = String::new();
        for (idx, byte) in chunk.iter().enumerate() {
            if idx > 0 {
                line.push_str(", ");
            }
            write!(&mut line, "0x{:02x}", byte).unwrap();
        }
        lines.push(format!(
            "{indentation}{line}",
            indentation = " ".repeat(indent),
            line = line
        ));
    }

    lines.join(",\n")
}

fn rust_string_literal(value: &str) -> String {
    let mut literal = String::from("\"");
    for ch in value.chars() {
        for escaped in ch.escape_default() {
            literal.push(escaped);
        }
    }
    literal.push('"');
    literal
}

fn workspace_root() -> PathBuf {
    PathBuf::from(env!("CARGO_MANIFEST_DIR"))
        .join("..")
        .join("..")
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::{flows, manifest, templates};

    fn demo_pack_dir() -> PathBuf {
        PathBuf::from(env!("CARGO_MANIFEST_DIR"))
            .join("..")
            .join("..")
            .join("examples/weather-demo")
    }

    #[test]
    fn component_data_contains_mcp_exec_flow_source() {
        let pack_dir = demo_pack_dir();
        let spec = manifest::load_spec(&pack_dir).expect("spec");
        let flow_assets = flows::load_flows(&pack_dir, &spec.spec).expect("flows");
        let template_assets =
            templates::collect_templates(&pack_dir, &spec.spec).expect("templates");
        let manifest_model = manifest::build_manifest(&spec, &flow_assets, &template_assets);
        let manifest_bytes = manifest::encode_manifest(&manifest_model).expect("manifest encoding");

        let generated =
            generate_component_data(&manifest_bytes, &flow_assets, &template_assets).unwrap();

        assert!(
            generated.contains("pub static MANIFEST_CBOR"),
            "generated source should expose MANIFEST_CBOR constant"
        );
        assert!(
            generated.contains("mcp.exec"),
            "generated flow bundle should retain mcp.exec reference"
        );
        assert!(
            generated.contains("templates/greeting.txt"),
            "template logical path should be present"
        );
    }

    #[test]
    fn indent_byte_literal_outputs_comma_separated_rows() {
        let bytes = [0x01u8, 0x02, 0x03, 0x04];
        let rendered = indent_byte_literal(&bytes, 4);
        assert_eq!(
            rendered, "    0x01, 0x02, 0x03, 0x04",
            "literal should match expected formatting"
        );
    }
}
